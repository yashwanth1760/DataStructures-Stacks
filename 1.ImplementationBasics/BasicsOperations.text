**üìå Stack ‚Äì Complete Theory**

**Definition**

A **Stack** is a **linear data structure** that follows the **LIFO (Last In, First Out)** principle.

* The last element pushed into the stack will be the first one to be popped out.
* Think of it like a stack of plates ‚Äî you add plates on top, and you remove from the top.

---

**üìå Properties of Stack**

1. **Order of Operations**: Follows **LIFO** (Last In, First Out)
2. **Restricted Access**: Insertion and deletion happen **only at one end** ‚Äî called the **top** of the stack.
3. **Dynamic or Static Size**:

   * Array-based stack ‚Üí fixed size (unless dynamic array used)
   * Linked list-based stack ‚Üí dynamic size
4. **Access Time**: You cannot randomly access elements; must pop until the desired element is on top.
5. **Efficient Operations**:

   * `push`, `pop`, `top` are **O(1)** time complexity.
6. **Memory**: Continuous memory in array implementation, scattered in linked list implementation.

---

**üìå Basic Operations**

| Operation          | Description                                          | Time Complexity |
| ------------------ | ---------------------------------------------------- | --------------- |
| **push(x)**        | Adds element `x` to the top of the stack.            | O(1)            |
| **pop()**          | Removes the top element of the stack.                | O(1)            |
| **top() / peek()** | Returns the top element **without** removing it.     | O(1)            |
| **size()**         | Returns the number of elements in the stack.         | O(1)            |
| **empty()**        | Checks if the stack is empty. Returns `true` if yes. | O(1)            |

---

**1Ô∏è‚É£ push(x)**

* **Meaning**: Insert `x` at the top.
* **Steps**: Increase top pointer ‚Üí place element at new top.
* **Complexity**: O(1)

---

**2Ô∏è‚É£ pop()**

* **Meaning**: Remove the element at the top.
* **Steps**: Remove top element ‚Üí decrease top pointer.
* **Complexity**: O(1)
  ‚ö† **Error**: Underflow (if pop is called on empty stack)

---

**3Ô∏è‚É£ top() / peek()**

* **Meaning**: Access the top element without removing it.
* **Complexity**: O(1)
  ‚ö† **Error**: Undefined for empty stack.

---

**4Ô∏è‚É£ size()**

* **Meaning**: Number of elements currently in the stack.
* **Complexity**: O(1) (if maintained as a counter)

---

**5Ô∏è‚É£ empty()**

* **Meaning**: Returns `true` if stack contains no elements.
* **Complexity**: O(1)

---
**üìå Stack Implementations**

1. **Array-based** (Static stack)

   * Pros: Fast access
   * Cons: Fixed size, possible overflow
2. **Linked List-based** (Dynamic stack)

   * Pros: No overflow (until memory full)
   * Cons: Slightly more memory per element (pointer storage)


//*****************//**************//***************//


we use STL for stack implementation in C++
stack<int>s;
s.push(1);
s.push(2);
s.size();
s.isempty();
s.top();

under the hood stack implemented by dequeue data structure in STL



vector vs stack 

in vector we  may waste  space if we insert element at the end of the vector and then we delete it from the end of the vector. But in stack we don't waste space because we always delete the top element of th stack.

1Ô∏è‚É£ Purpose & Abstraction
std::stack is a container adaptor in C++ that provides only the stack interface (push, pop, top, empty, size).

With a vector, you have extra functions (insert, erase, operator[]) that don‚Äôt belong to a pure LIFO structure.

Using stack makes it clear in code that you‚Äôre working with a LIFO structure, not a random-access container.

2Ô∏è‚É£ Flexibility of Implementation
std::stack can be built on vector, deque (default), or list ‚Äî so you can swap the underlying container without changing logic.

A pure vector-based stack has one fixed implementation.

3Ô∏è‚É£ Algorithmic Usage
In algorithm design, ‚Äústack‚Äù isn‚Äôt just about where you store data ‚Äî it‚Äôs about the discipline of LIFO access.

Many problems (DFS, expression evaluation, parentheses matching, recursion simulation, monotonic stack problems) rely on LIFO behavior.

Teaching & theory: Stacks are a foundational data structure in DSA education and interviews.

4Ô∏è‚É£ Performance Notes
Vector‚Äôs push_back / pop_back are O(1) amortized ‚Äî so for stack-like usage, vector is fine.

But if you need a linked-list stack (no contiguous memory needed, fast allocation/deallocation of arbitrary sizes), stack with list underneath might be better.

Stack implemented with a vector might waste space because vector can allocate extra capacity to grow dynamically.

5Ô∏è‚É£ Safety & Intent
With stack, you cannot accidentally access elements out of LIFO order ‚Äî no operator[], no begin() iterator.

This enforces correct algorithmic usage and prevents mistakes.

